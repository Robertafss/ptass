, when, nx: bool = ..., xx: bool = ..., gt: bool = ..., lt: bool = ...) -> Any: ...  # type: ignore[override]
    def get(self, name: _Key) -> Any: ...  # type: ignore[override]
    def getdel(self, name: _Key) -> Any: ...  # type: ignore[override]
    def getex(  # type: ignore[override]
        self,
        name,
        ex: Incomplete | None = ...,
        px: Incomplete | None = ...,
        exat: Incomplete | None = ...,
        pxat: Incomplete | None = ...,
        persist: bool = ...,
    ) -> Any: ...
    def getbit(self, name: _Key, offset: int) -> Any: ...  # type: ignore[override]
    def getrange(self, key, start, end) -> Any: ...  # type: ignore[override]
    def getset(self, name, value) -> Any: ...  # type: ignore[override]
    def incr(self, name: _Key, amount: int = ...) -> Any: ...  # type: ignore[override]
    def incrby(self, name: _Key, amount: int = ...) -> Any: ...  # type: ignore[override]
    def incrbyfloat(self, name: _Key, amount: float = ...) -> Any: ...  # type: ignore[override]
    def keys(self, pattern: _Key = ..., **kwargs: _CommandOptions) -> Any: ...  # type: ignore[override]
    def lmove(  # type: ignore[override]
        self, first_list: _Key, second_list: _Key, src: Literal["LEFT", "RIGHT"] = ..., dest: Literal["LEFT", "RIGHT"] = ...
    ) -> Any: ...
    def blmove(  # type: ignore[override]
        self,
        first_list: _Key,
        second_list: _Key,
        timeout: float,
        src: Literal["LEFT", "RIGHT"] = ...,
        dest: Literal["LEFT", "RIGHT"] = ...,
    ) -> Any: ...
    def mget(self, keys: _Key | Iterable[_Key], *args: _Key) -> Any: ...  # type: ignore[override]
    def mset(self, mapping: Mapping[_Key, _Value]) -> Any: ...  # type: ignore[override]
    def msetnx(self, mapping: Mapping[_Key, _Value]) -> Any: ...  # type: ignore[override]
    def move(self, name: _Key, db: int) -> Any: ...  # type: ignore[override]
    def persist(self, name: _Key) -> Any: ...  # type: ignore[override]
    def pexpire(  # type: ignore[override]
        self, name: _Key, time: int | timedelta, nx: bool = ..., xx: bool = ..., gt: bool = ..., lt: bool = ...
    ) -> Any: ...
    def pexpireat(  # type: ignore[override]
        self, name: _Key, when: int | datetime, nx: bool = ..., xx: bool = ..., gt: bool = ..., lt: bool = ...
    ) -> Any: ...
    def psetex(self, name, time_ms, value) -> Any: ...  # type: ignore[override]
    def pttl(self, name: _Key) -> Any: ...  # type: ignore[override]
    def hrandfield(self, key, count: Incomplete | None = ..., withvalues: bool = ...) -> Any: ...  # type: ignore[override]
    def randomkey(self, **kwargs: _CommandOptions) -> Any: ...  # type: ignore[override]
    def rename(self, src, dst) -> Any: ...  # type: ignore[override]
    def renamenx(self, src, dst) -> Any: ...  # type: ignore[override]
    def restore(  # type: ignore[override]
        self,
        name,
        ttl,
        value,
        replace: bool = ...,
        absttl: bool = ...,
        idletime: Incomplete | None = ...,
        frequency: Incomplete | None = ...,
    ) -> Any: ...
    def set(  # type: ignore[override]
        self,
        name: _Key,
        value: _Value,
        ex: None | int | timedelta = ...,
        px: None | int | timedelta = ...,
        nx: bool = ...,
        xx: bool = ...,
        keepttl: bool = ...,
        get: bool = ...,
        exat: Incomplete | None = ...,
        pxat: Incomplete | None = ...,
    ) -> Any: ...
    def setbit(self, name: _Key, offset: int, value: int) -> Any: ...  # type: ignore[override]
    def setex(self, name: _Key, time: int | timedelta, value: _Value) -> Any: ...  # type: ignore[override]
    def setnx(self, name: _Key, value: _Value) -> Any: ...  # type: ignore[override]
    def setrange(self, name, offset, value) -> Any: ...  # type: ignore[override]
    def stralgo(  # type: ignore[override]
        self,
        algo,
        value1,
        value2,
        specific_argument: str = ...,
        len: bool = ...,
        idx: bool = ...,
        minmatchlen: Incomplete | None = ...,
        withmr(row[c], ts, '| ');
                str += ts;
                str += addBorder(row[c], ts, ' |');
                if (padding[right]) {
                    str += ' '.repeat(padding[right]);
                }
                // if prior row is span, try to render the
                // current row on the prior line.
                if (r === 0 && lines.length > 0) {
                    str = this.renderInline(str, lines[lines.length - 1]);
                }
            });
            // remove trailing whitespace.
            lines.push({
                text: str.replace(/ +$/, ''),
                span: row.span
            });
        });
        return lines;
    }
    // if the full 'source' can render in
    // the target line, do so.
    renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) {
            return source;
        }
        // if we're not applying wrapping logic,
        // just always append to the span.
        if (!this.wrap) {
            previousLine.hidden = true;
            return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
            return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
    }
    rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        // word wrap all columns, and create
        // a data-structure that is easy to rasterize.
        row.forEach((col, c) => {
            // leave room for left and right padding.
            col.width = widths[c];
            if (this.wrap) {
                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\n');
            }
            else {
                wrapped = col.text.split('\n');
            }
            if (col.border) {
                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
            }
            // add top and bottom padding.
            if (col.padding) {
                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));
                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));
            }
            wrapped.forEach((str, r) => {
                if (!rrows[r]) {
                    rrows.push([]);
                }
                const rrow = rrows[r];
                for (let i = 0; i < c; i++) {
                    if (rrow[i] === undefined) {
                        rrow.push('');
                    }
                }
                rrow.push(str);
            });
        });
        return rrows;
    }
    negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
            wrapWidth -= 4;
        }
        return wrapWidth;
    }
    columnWidths(row) {
        if (!this.wrap) {
            return row.map(col => {
                return col.width || mixin.stringWidth(col.text);
            });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        // column widths can be set in config.
        const widths = row.map(col => {
            if (col.width) {
                unset--;
                remainingWidth -= col.width;
                return col.width;
            }
            return undefined;
        });
        // any unset widths should be calculated.
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => {
            if (w === undefined) {
                return Math.max(unsetWidth, _minWidth(row[i]));
            }
            return w;
        });
    }
}
function addBorder(col, ts, style) {
    if (col.border) {
        if (/[.']-+[.']/.test(ts)) {
            return '';
        }
        if (ts.trim().length !== 0) {
            return style;
        }
        return '  ';
    }
    return '';
}
// calculates the minimum width of
// a column, based on padding preferences.
function _minWidth(col) {
    const padding = col.padding || [];
    const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
    if (col.border) {
        return minWidth + 4;
    }
    return minWidth;
}
function getWindowWidth() {
    /* istanbul ignore next: depends on terminal */
    if (typeof process === 'object' && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
    }
    return 80;
}
function alignRight(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    if (strWidth < width) {
        return ' '.repeat(width - strWidth) + str;
    }
    return str;
}
function alignCenter(str, width) {
    str = str.trim();
    const strWidth = mixin.stringWidth(str);
    /* istanbul ignore next */
    if (strWidth >= width) {
        return str;
    }
    return ' '.repeat((width - strWidth) >> 1) + str;
}
let mixin;
export function cliui(opts, _mixin) {
    mixin = _mixin;
    return new UI({
        width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
        wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
    });
}

a multinomial distribution.\n\n        The multinomial distribution is a multivariate generalization of the\n        binomial distribution.  Take an experiment with one of ``p``\n        possible outcomes.  An example of such an experiment is throwing a dice,\n        where the outcome can be 1 through 6.  Each sample drawn from the\n        distribution represents `n` such experiments.  Its values,\n        ``X_i = [X_0, X_1, ..., X_p]``, represent the number of times the\n        outcome was ``i``.\n\n        Parameters\n        ----------\n        n : int or array-like of ints\n            Number of experiments.\n        pvals : sequence of floats, length p\n            Probabilities of each of the ``p`` different outcomes.  These\n            must sum to 1 (however, the last element is always assumed to\n            account for the remaining probability, as long as\n            ``sum(pvals[:-1]) <= 1)``.\n        size : int or tuple of ints, optional\n            Output shape.  If the given shape is, e.g., ``(m, n, k)``, then\n            ``m * n * k`` samples are drawn.  Default is None, in which case a\n            single value is returned.\n\n        Returns\n        -------\n        out : ndarray\n            The drawn samples, of shape *size*, if that was provided.  If not,\n            the shape is ``(N,)``.\n\n            In other words, each entry ``out[i,j,...,:]`` is an N-dimensional\n            value drawn from the distribution.\n\n        Examples\n        --------\n        Throw a dice 20 times:\n\n        >>> rng = np.random.default_rng()\n        >>> rng.multinomial(20, [1/6.]*6, size=1)\n        array([[4, 1, 7, 5, 2, 1]])  # random\n\n        It landed 4 times on 1, once on 2, etc.\n\n        Now, throw the dice 20 times, and 20 times again:\n\n        >>> rng.multinomial(20, [1/6.]*6, size=2)\n        array([[3, 4, 3, 3, 4, 3],\n               [2, 4, 3, 4, 0, 7]])  # random\n\n        For the first run, we threw 3 times 1, 4 times 2, etc.  For the second,\n        we threw 2 times 1, 4 times 2, etc.\n\n        Now, do one experiment throwing the dice 10 time, and 10 times again,\n        and another throwing the dice 20 times, and 20 times again:\n\n        >>> rng.multinomial([[10], [20]], [1/6.]*6, size=(2, 2))\n        array([[[2, 4, 0, 1, 2, 1],\n                [1, 3, 0, 3, 1, 2]],\n               [[1, 4, 4, 4, 4, 3],\n                [3, 3, 2, 5, 5, 2]]])  # random\n\n        The first array shows the outcomes of throwing the dice 10 times, and\n        the second shows the outcomes from throwing the dice 20 times.\n\n        A loaded die is more likely to land on number 6:\n\n        >>> rng.multinomial(100, [1/7.]*5 + [2/7.])\n        array([11, 16, 14, 17, 16, 26])  # random\n\n        The probability inputs should be normalized. As an implementation\n        detail, the value of the last entry is ignored and assumed to take\n        up any leftover probability mass, but this should not be relied on.\n        A biased coin which has twice as much weight on one side as on the\n        other should be sampled like so:\n\n        >>> rng.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT\n        array([38, 62])  # random\n\n        not like:\n\n        >>> rng.multinomial(100, [1.0, 2.0])  # WRONG\n        Traceback (most recent call last):\n        ValueError: pvals < 0, pvals > 1 or pvals contains NaNs\n\n        '
        ...
    
    def multivariate_hypergeometric(self, colors, nsample, size=..., method=...) -> typing.Any:
        '\n        multivariate_hypergeometric(colors, nsample, size=None,\n                                    method=\'marginals\')\n\n        Generate variates from a multivariate hypergeometric distribution.\n\n        The multivariate hypergeometric distribution is a generalization\n        of the hypergeometric distribution.\n\n        Choose ``nsample`` items at random without replacement from a\n        collection with ``N`` distinct types.  ``N`` is the length of\n        ``colors``, and the values in ``colors`` are the number of occurrences\n        of that type in the collection.  The total number of items in the\n        collection is ``sum(colors)``.  Each random variate generated by this\n        function is a vector of length ``N`` holding the counts of the\n        different types that occurred in the ``nsample`` items.\n\n        The name ``colors`` comes from a common description of the\n        distribution: it is the probability distribution of the number of\n        marbles of each color selected without replacement from an urn\n        containing marbles of different colors; ``colors[i]`` is the number\n        of marbles in the urn with color ``i``.\n\n        Parameters\n        ----------\n        colors : sequence of integers\n            The number of each type of item in the collection from which\n            a sample is drawn.  The values in ``colors`` must be nonnegative.\n            To avoid loss of precision in the algorithm, ``sum(colors)``\n            must be less than ``10**9`` when `method` is "marginals".\n        nsample : int\n            The number of items selected.  ``nsample`` must not be greater\n            than ``sum(colors)``.\n        size : int or tuple of ints, optional\n            The number of variates to generate, either an integer or a tuple\n            holding the shape of the array of variates.  If the given size is,\n            e.g., ``(k, m)``, then ``k * m`` variates are drawn, where one\n            variate is a